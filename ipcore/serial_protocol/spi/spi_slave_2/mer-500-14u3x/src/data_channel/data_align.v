//-------------------------------------------------------------------------------------------------
//  -- 版权所有者   : 中国大恒（集团）有限公司北京图像视觉技术分公司, 2010 -2015.
//  -- 保密级别     ：绝密.
//  -- 部门         : 硬件部，FPGA工作组
//  -- 模块名       : data_align
//  -- 设计者       : 邢海涛
//-------------------------------------------------------------------------------------------------
//
//  -- 版本记录 :
//
//  -- 作者         :| 修改日期				:|  修改说明
//-------------------------------------------------------------------------------------------------
//  -- 邢海涛       :| 2014/12/5 15:44:31	:|  初始版本
//-------------------------------------------------------------------------------------------------
//
//  -- 模块描述     : 数据拼接模块
//              1)  : 根据pixel format的数据位宽，选择拼接方式。输出位宽固定为32bit
//
//              2)  : 如果pixel format的数据位宽是8bit，选择输入数据的高8bit，每4个像素拼接为1个32bit数据，先到来的数据放在低位
//
//              3)  : 如果pixel format的数据位宽是10bit，选择输入数据高10bit，每2个像素拼接为1个32bit数据，先到来的数据放在低位
//
//-------------------------------------------------------------------------------------------------
//仿真单位/精度
`timescale 1ns/1ps
//-------------------------------------------------------------------------------------------------

module data_align # (
	parameter	SENSOR_DAT_WIDTH	= 10	,	//sensor 数据宽度
	parameter	REG_WD				= 32	,	//寄存器位宽
	parameter	DATA_WD				= 32		//输入输出数据位宽，这里使用同一宽度
	)
	(
	//Sensor输入信号
	input								clk				,	//像素时钟
	input								i_fval			,	//场信号
	input								i_lval			,	//行信号
	input	[SENSOR_DAT_WIDTH-1:0]		iv_pix_data		,	//图像数据
	//灰度统计相关寄存器
	input	[REG_WD-1:0]				iv_pixel_format	,	//像素格式寄存器，0x01080001:Mono8、0x01100003:Mono10、0x01080008:BayerGR8、0x0110000C:BayerGR10
	//输出
	output								o_fval			,	//场有效
	output								o_pix_data_en	,	//数据有效信号，数据拼接之后的使能信号，相当于时钟的2分频或者4分频
	output	[DATA_WD-1:0]				ov_pix_data			//图像数据
	);

	//	ref signals
	reg							format8_sel		= 1'b0;
	reg		[DATA_WD-1:0]		pix_data_shift	= {DATA_WD{1'b0}};
	reg		[DATA_WD-1:0]		pix_data_reg	= {DATA_WD{1'b0}};
	reg		[1:0]				pix_cnt			= 2'b0;
	reg							data_en			= 1'b0;
	reg							data_en_dly		= 1'b0;
	reg							fval_dly0		= 1'b0;
	reg							fval_dly1		= 1'b0;

	//	ref ARCHITECTURE
	//  ===============================================================================================
	//	ref ***判断数据格式***
	//  ===============================================================================================
	//  -------------------------------------------------------------------------------------
	//	Mono8		- 0x01080001	-> 0x1081	-> 0001,0000,1000,,,,0001
	//	Mono10		- 0x01100003	-> 0x1103	-> 0001,0001,0000,,,,0011
	//	BayerGR8	- 0x01080008	-> 0x1088	-> 0001,0000,1000,,,,1000
	//	BayerGR10	- 0x0110000C	-> 0x110C	-> 0001,0001,0000,,,,1100
	//											   --------!-!-------!!!!
	//                                                     ^    ^       ^------bit0
	//                                             bit20---|    |---bit16
	//	标记上 ! 的，就是参与比较的bit.分别是 bit 20 19 3-0
	//  -------------------------------------------------------------------------------------
	//  -------------------------------------------------------------------------------------
	//	format8_sel
	//	1.判断像素格式是否选中8bit像素格式
	//	2.使用6bit判断依据
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		case({iv_pixel_format[20],iv_pixel_format[19],iv_pixel_format[3:0]})
			6'b010001	: format8_sel	<= 1'b1;
			6'b011000	: format8_sel	<= 1'b1;
			default		: format8_sel	<= 1'b0;
		endcase
	end

	//  ===============================================================================================
	//	ref ***数据移位***
	//  ===============================================================================================
	//  -------------------------------------------------------------------------------------
	//	数据移位寄存器
	//	1.当场消隐时，移位寄存器清零
	//	2.当场有效且行有效时，如果像素格式是8bit，每个像素占据1个byte，只取像素的高8bit
	//	3.当场有效且行有效时，如果像素格式是10bit，每个像素占据2个byte，，只取像素的高10bit，高位填充0
	//	4.数据移位寄存器位宽-32bit
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		if(!i_fval) begin
			pix_data_shift	<= {DATA_WD{1'b0}};
		end
		else begin
			if(i_lval) begin
				//  -------------------------------------------------------------------------------------
				//	像素格式8bit
				//  -------------------------------------------------------------------------------------
				if(format8_sel) begin
					pix_data_shift	<= {iv_pix_data[SENSOR_DAT_WIDTH-1:SENSOR_DAT_WIDTH-8],pix_data_shift[DATA_WD-1:8]};
				end
				//  -------------------------------------------------------------------------------------
				//	像素格式10bit
				//  -------------------------------------------------------------------------------------
				else begin
					pix_data_shift	<= {6'b0,iv_pix_data[SENSOR_DAT_WIDTH-1:SENSOR_DAT_WIDTH-10],pix_data_shift[DATA_WD-1:16]};
				end
			end
		end
	end

	//  -------------------------------------------------------------------------------------
	//	像素计数器
	//	1.场消隐时，清零
	//	2.场有效且行有效时，计数器累加
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		if(!i_fval) begin
			pix_cnt	<= 2'b0;
		end
		else begin
			if(i_lval) begin
				pix_cnt	<= pix_cnt + 1'b1;
			end
		end
	end

	//  -------------------------------------------------------------------------------------
	//	data_en 数据使能信号，代替o_lval
	//	1.当场消隐的时候，数据使能必须是0.
	//	2.当场有效的时候，当行有效时，如果像素格式8bit，每4个周期，产生1个数据使能
	//	3.当场有效的时候，当行有效时，如果像素格式10bit，每2个周期，产生1个数据使能
	//	4.当场有效的时候，当行无效时，数据使能无效
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		if(!i_fval) begin
			data_en	<= 1'b0;
		end
		else begin
			if(i_lval) begin
				//  -------------------------------------------------------------------------------------
				//	像素格式8bit
				//  -------------------------------------------------------------------------------------
				if(format8_sel) begin
					if(pix_cnt==2'b11) begin
						data_en	<= 1'b1;
					end
					else begin
						data_en	<= 1'b0;
					end
				end
				//  -------------------------------------------------------------------------------------
				//	像素格式10bit
				//  -------------------------------------------------------------------------------------
				else begin
					if(pix_cnt[0]==1'b1) begin
						data_en	<= 1'b1;
					end
					else begin
						data_en	<= 1'b0;
					end
				end
			end
			else begin
				data_en	<= 1'b0;
			end
		end
	end

	//  ===============================================================================================
	//	ref ***行场信号、数据输出***
	//  ===============================================================================================
	//  -------------------------------------------------------------------------------------
	//	fval 输出
	//	1.从结尾处看，数据延时了2个时钟输出，因此要对fval延时2个时钟周期
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		fval_dly0	<= i_fval;
		fval_dly1	<= fval_dly0;
	end

	//	-------------------------------------------------------------------------------------
	//	对data_en延时1拍，因为数据的处理滞后了一拍，所以要延时
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		data_en_dly	<= data_en;
	end

	//	-------------------------------------------------------------------------------------
	//	判断输出数据，如果不使能，则输出为全零
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		if(data_en) begin
			pix_data_reg	<= pix_data_shift;
		end
		else begin
			pix_data_reg	<= {DATA_WD{1'b0}};
		end
	end

	//  -------------------------------------------------------------------------------------
	//	输出
	//  -------------------------------------------------------------------------------------
	assign	o_pix_data_en	= data_en_dly;
	assign	ov_pix_data		= pix_data_reg;
	assign	o_fval			= fval_dly1;



endmodule
