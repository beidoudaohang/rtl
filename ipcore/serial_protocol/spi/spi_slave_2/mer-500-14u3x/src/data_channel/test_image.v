//-------------------------------------------------------------------------------------------------
//  -- 版权所有者   : 中国大恒（集团）有限公司北京图像视觉技术分公司, 2010 -2015.
//  -- 保密级别     ：绝密.
//  -- 部门         : 硬件部，FPGA工作组
//  -- 模块名       : test_image
//  -- 设计者       : 邢海涛
//-------------------------------------------------------------------------------------------------
//
//  -- 版本记录 :
//
//  -- 作者         :| 修改日期				:|  修改说明
//-------------------------------------------------------------------------------------------------
//  -- 邢海涛       :| 2014/12/4 13:41:28	:|  初始版本
//-------------------------------------------------------------------------------------------------
//
//  -- 模块描述     : 测试图模块，共有三种测试图
//              1)  : 灰度值递增
//						整帧图像都是一个像素值，高8bit每帧递增1，递增到255时，下一个数为0。
//              2)  : 静态斜条纹(0-255斜条纹)
//						每一行中，像素从左到右递增。高8bit每个像素递增1，递增到255时，下一个数为0。
//						第一个像素点的数值是全0。
//              2)  : 动态斜条纹(0-255滚动斜条纹)
//						与0-255斜条纹类似，只是每一帧过后，每个像素点递增。高8bit每个像素递增1，递增到255时，下一个数为0。
//-------------------------------------------------------------------------------------------------
//仿真单位/精度
`timescale 1ns/1ps
//-------------------------------------------------------------------------------------------------

module test_image # (
	parameter	SENSOR_DAT_WIDTH	= 10		//sensor 数据宽度
	)
	(
	//Sensor输入信号
	input								clk					,	//像素时钟
	input								i_fval				,	//场信号
	input								i_lval				,	//行信号
	input	[SENSOR_DAT_WIDTH-1:0]		iv_pix_data			,	//图像数据
	//寄存器数据
	input	[2:0]						iv_test_image_sel	,	//测试图选择寄存器,000:真实图,001:测试图像1灰度值帧递增,110:测试图像2静止的斜条纹,010:测试图像3滚动的斜条纹
	//输出
	output								o_fval				,	//场有效，o_fval与o_lval的相位要保证与输入的相位一致
	output								o_lval				,	//行有效
	output	[SENSOR_DAT_WIDTH-1:0]		ov_pix_data				//图像数据
	);

	//	ref signals
	reg									fval_dly			= 1'b0;
	wire								fval_fall			;
	reg									lval_dly			= 1'b0;
	wire								lval_fall			;
	reg		[7:0]						frame_cnt			= 8'b0;
	reg		[7:0]						line_cnt			= 8'b0;
	reg		[7:0]						col_cnt				= 8'b0;
	reg		[SENSOR_DAT_WIDTH-1:0]		pix_data_reg		= {SENSOR_DAT_WIDTH{1'b0}};

	//	ref ARCHITECTURE


	//  ===============================================================================================
	//	ref ***提取边沿***
	//  ===============================================================================================
	//  -------------------------------------------------------------------------------------
	//	fval 提取边沿
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		fval_dly	<= i_fval;
	end
	assign	fval_fall	= (fval_dly==1'b1 && i_fval==1'b0) ? 1'b1 : 1'b0;

	//  -------------------------------------------------------------------------------------
	//	lval 提取边沿
	//	1.当输入场信号无效时，屏蔽行信号
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		if(i_fval) begin
			lval_dly	<= i_lval;
		end
		else begin
			lval_dly	<= 1'b0;
		end
	end
	assign	lval_fall	= (lval_dly==1'b1 && i_lval==1'b0) ? 1'b1 : 1'b0;

	//  ===============================================================================================
	//	ref ***主要计数器动作***
	//  ===============================================================================================
	//  -------------------------------------------------------------------------------------
	//	帧计数器
	//	1.当测试图寄存器=000时，真实图。frame_cnt复位为全0；
	//	2.当测试图寄存器=001时，灰度值递增测试图。frame_cnt复位为全0；
	//	3.当测试图寄存器=110时，0-255静态斜条纹测试图。frame_cnt复位为全0；
	//	4.当测试图寄存器=010时，0-255滚动斜条纹测试图。在i_fval下降沿的时候，frame_cnt递增1。

	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		case(iv_test_image_sel)
			3'b000,3'b001,3'b110	: frame_cnt	<= 2'b00;
			3'b010	: begin
				if(fval_fall) begin
					frame_cnt	<= frame_cnt + 1'b1;
				end
			end
			default	: frame_cnt	<= 2'b00;
		endcase
	end

	//  -------------------------------------------------------------------------------------
	//	行计数器
	//	1.当测试图寄存器=000时，真实图。line_cnt=frame_cnt；
	//	2.当测试图寄存器=001时，灰度值递增测试图。line_cnt=frame_cnt；
	//	3.当测试图寄存器=110时，0-255静态斜条纹测试图。当i_fval=0时，line_cnt=frame_cnt；当i_fval=1时，在i_lval的下降沿递增1。
	//	4.当测试图寄存器=010时，0-255滚动斜条纹测试图。当i_fval=0时，line_cnt=frame_cnt；当i_fval=1时，在i_lval的下降沿递增1。

	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		case(iv_test_image_sel)
			3'b000,3'b001	: line_cnt	<= frame_cnt;
			3'b110,3'b010	: begin
				if(!i_fval) begin
					line_cnt	<= frame_cnt;
				end
				else begin
					if(lval_fall) begin
						line_cnt	<= line_cnt + 1'b1;
					end
				end
			end
			default		: line_cnt	<= frame_cnt;
		endcase
	end

	//  -------------------------------------------------------------------------------------
	//	列计数器
	//	1.当测试图寄存器=000时，真实图。col_cnt=line_cnt；
	//	2.当测试图寄存器=001时，灰度值递增测试图。i_fval下降沿时col_cnt递增1；
	//	3.当测试图寄存器=110时，0-255静态斜条纹测试图。i_fval=1时且i_lval=1时，col_cnt递增1；其他情况下，col_cnt=line_cnt；
	//	4.当测试图寄存器=010时，0-255滚动斜条纹测试图。i_fval=1时且i_lval=1时，col_cnt递增1；其他情况下，col_cnt=line_cnt；
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		case(iv_test_image_sel)
			3'b000	: col_cnt	<= line_cnt;
			3'b001	: begin
				if(fval_fall) begin
					col_cnt	<= col_cnt + 1'b1;
				end
			end
			3'b110,3'b010	: begin
				if(i_fval&i_lval) begin
					col_cnt	<= col_cnt + 1'b1;
				end
				else begin
					col_cnt	<= line_cnt;
				end
			end
			default		: col_cnt	<= line_cnt;
		endcase
	end

	//  ===============================================================================================
	//	ref ***输出***
	//  ===============================================================================================
	//  -------------------------------------------------------------------------------------
	//	选择输出数据
	//	1.当输入的行场信号都有效时
	//	--1.1如果是真实图，则输出数据=输入数据
	//	--1.2如果是测试图，则输出数据中的高8bit用测试数据代替，低位填充0。后面的结尾模块，会把低位截取，因此数据要放在高位
	//	2.当输入的行场信号有一个无效时，数据屏蔽为0
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		if(i_fval==1'b1 && i_lval==1'b1) begin
			if(iv_test_image_sel==3'b000) begin
				pix_data_reg	<= iv_pix_data;
			end
			else begin
				pix_data_reg	<= {col_cnt[7:0],{(SENSOR_DAT_WIDTH-8){1'b0}}};
			end
		end
		else begin
			pix_data_reg	<= {SENSOR_DAT_WIDTH{1'b0}};
		end
	end

	//  -------------------------------------------------------------------------------------
	//	输出数据，行场信号，延时都是1拍
	//  -------------------------------------------------------------------------------------
	assign	ov_pix_data			= pix_data_reg;
	assign	o_fval				= fval_dly;
	assign	o_lval				= lval_dly;



endmodule
