//-------------------------------------------------------------------------------------------------
//  -- 版权所有者   : 中国大恒（集团）有限公司北京图像视觉技术分公司, 2010 -2015.
//  -- 保密级别     ：绝密.
//  -- 部门         : 硬件部，FPGA工作组
//  -- 模块名       : wb_gain
//  -- 设计者       : 邢海涛
//-------------------------------------------------------------------------------------------------
//
//  -- 版本记录 :
//
//  -- 作者         :| 修改日期				:|  修改说明
//-------------------------------------------------------------------------------------------------
//  -- 邢海涛       :| 2015/2/13 10:31:49	:|  初始版本
//-------------------------------------------------------------------------------------------------
//
//  -- 模块描述     : 颜色分量增益模块
//              1)  : 总体延时3个时钟
//
//              2)  : ... ...
//
//              3)  : ... ...
//
//-------------------------------------------------------------------------------------------------
//仿真单位/精度
`timescale 1ns/1ps
//-------------------------------------------------------------------------------------------------

module wb_gain # (
	parameter					SENSOR_DAT_WIDTH	= 10	,	//sensor 数据宽度
	parameter					WB_GAIN_WIDTH		= 11	,	//白平衡模块增益寄存器宽度
	parameter					WB_RATIO			= 8		,	//白平衡调节因子，乘法增益需要右移多少位
	parameter					REG_WD				= 32		//寄存器位宽
	)
	(
	input								clk					,	//时钟输入
	input								i_fval				,	//场信号
	input								i_lval				,	//行信号
	input	[SENSOR_DAT_WIDTH-1:0]		iv_pix_data			,	//图像数据
	input								i_r_flag			,	//颜色分量标志 R
	input								i_g_flag			,	//颜色分量标志 G
	input								i_b_flag			,	//颜色分量标志 B
	input	[REG_WD-1:0]				iv_pixel_format		,	//0x01080001:Mono8、0x01100003:Mono10、0x01080008:BayerGR8、0x0110000C:BayerGR10。黑白的时候，不做乘法。
	input	[2:0]						iv_test_image_sel	,	//测试图选择寄存器,000:真实图,001:测试图像1灰度值帧递增,110:测试图像2静止的斜条纹,010:测试图像3滚动的斜条纹
	input	[WB_GAIN_WIDTH-1:0]			iv_wb_gain_r		,	//白平衡R分量，R分量小数乘以256后的结果，取值范围[0:2047]
	input	[WB_GAIN_WIDTH-1:0]			iv_wb_gain_g		,	//白平衡G分量，G分量小数乘以256后的结果，取值范围[0:2047]
	input	[WB_GAIN_WIDTH-1:0]			iv_wb_gain_b		,	//白平衡B分量，B分量小数乘以256后的结果，取值范围[0:2047]
	output								o_fval				,	//场有效，o_fval与o_lval的相位要保证与输入的相位一致
	output								o_lval				,	//行有效
	output	[SENSOR_DAT_WIDTH-1:0]		ov_pix_data				//图像数据
	);

	//	ref signals
	reg														mono_sel		= 1'b0;
	wire													gain_enable		;
	reg		[WB_GAIN_WIDTH-1:0]								gain_coe		= {WB_GAIN_WIDTH{1'b0}};
	reg		[SENSOR_DAT_WIDTH-1:0]							pix_data_dly0	= {SENSOR_DAT_WIDTH{1'b0}};
	reg		[SENSOR_DAT_WIDTH-1:0]							pix_data_dly1	= {SENSOR_DAT_WIDTH{1'b0}};
	reg		[SENSOR_DAT_WIDTH-1:0]							pix_data_reg	= {SENSOR_DAT_WIDTH{1'b0}};
	wire	[16:0]											wb_mult_a		;
	wire	[16:0]											wb_mult_b		;
	wire	[33:0]											wb_mult_p		;
	reg														wb_mult_ce		= 1'b0;
	wire	[(WB_GAIN_WIDTH+SENSOR_DAT_WIDTH-1):0]			gain_all_data	;	//DSP结果中所有有效的数据位
	wire	[(WB_GAIN_WIDTH+SENSOR_DAT_WIDTH-WB_RATIO-1):0]	gain_reduce		;	//DSP结果中所有有效的数据位移位之后的结果
	wire	[(WB_GAIN_WIDTH-WB_RATIO-1):0]					gain_overflow	;	//DSP结果中所有有效的数据位的溢出位
	reg														fval_dly0		= 1'b0;
	reg														fval_dly1		= 1'b0;
	reg														fval_dly2		= 1'b0;
	reg														lval_dly0		= 1'b0;
	reg														lval_dly1		= 1'b0;
	reg														lval_dly2		= 1'b0;
	reg		[WB_GAIN_WIDTH-1							:0]	wb_gain_r_m=0	;	//经过生效时机控制的白平衡参数红分量
	reg		[WB_GAIN_WIDTH-1							:0]	wb_gain_g_m=0	;   //经过生效时机控制的白平衡参数绿分量
	reg		[WB_GAIN_WIDTH-1							:0]	wb_gain_b_m=0	;   //经过生效时机控制的白平衡参数蓝分量

	//	ref ARCHITECTURE
	//  ===============================================================================================
	//	ref ***生效时机***
	//  ===============================================================================================
	//  -------------------------------------------------------------------------------------
	//	像素格式选中黑白模式
	//  -------------------------------------------------------------------------------------
	//  -------------------------------------------------------------------------------------
	//	Mono8		- 0x01080001	-> 0x1081	-> 0001,0000,1000,,,,0001
	//	Mono10		- 0x01100003	-> 0x1103	-> 0001,0001,0000,,,,0011
	//	BayerGR8	- 0x01080008	-> 0x1088	-> 0001,0000,1000,,,,1000
	//	BayerGR10	- 0x0110000C	-> 0x110C	-> 0001,0001,0000,,,,1100
	//											   --------!-!-------!!!!
	//                                                     ^    ^       ^------bit0
	//                                             bit20---|    |---bit16
	//	标记上 ! 的，就是参与比较的bit.分别是 bit
	//  -------------------------------------------------------------------------------------
	//  -------------------------------------------------------------------------------------
	//	为了保留扩展，使用6bit判断依据
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		case({iv_pixel_format[20],iv_pixel_format[19],iv_pixel_format[3:0]})
			6'b010001	: mono_sel	<= 1'b1;
			6'b100011	: mono_sel	<= 1'b1;
			default		: mono_sel	<= 1'b0;
		endcase
	end

	//  -------------------------------------------------------------------------------------
	//	乘法增益使能控制
	//	1.当像素格式是彩色，且没有选中测试图时，才会做乘法增益
	//	2.否则，直接输出数据
	//  -------------------------------------------------------------------------------------
	assign	gain_enable	= (mono_sel==1'b0 && iv_test_image_sel==3'b000) ? 1'b1 : 1'b0;

	//  -------------------------------------------------------------------------------------
	//	增益系数 gain coefficient
	//  -------------------------------------------------------------------------------------

	always @ (posedge clk) begin
		if(!i_fval) begin
			wb_gain_r_m	<=  iv_wb_gain_r;
			wb_gain_g_m <=  iv_wb_gain_g;
			wb_gain_b_m <=  iv_wb_gain_b;
		end
	end

	always @ (posedge clk) begin
		if(i_r_flag) begin
			gain_coe	<= wb_gain_r_m;
		end
		else if(i_g_flag) begin
			gain_coe	<= wb_gain_g_m;
		end
		else if(i_b_flag) begin
			gain_coe	<= wb_gain_b_m;
		end
	end

	//  -------------------------------------------------------------------------------------
	//	数据延时
	//	1.根据 r g b 的标志选择合适的增益，需要1拍时间，因此数据也要延时一拍
	//	2.DSP乘法器延时1拍，因此数据要延时2拍，才能与DSP的输出对齐。以便后面的mux逻辑做选择
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		pix_data_dly0	<= iv_pix_data;
		pix_data_dly1	<= pix_data_dly0;
	end

	//  ===============================================================================================
	//	ref ***乘法器相关***
	//  ===============================================================================================
	//  -------------------------------------------------------------------------------------
	//	乘法器
	//	1.ce使能，当不输出数据的时候，使能关闭，节省功耗
	//	2.乘法器输入位宽17，输出位宽34，目的是方便扩展。DSP的高bit没有用到，在布局布线时会被优化。
	//	3.内部有1个pipelin
	//  -------------------------------------------------------------------------------------
	wb_mult_a17b17p34 wb_mult_a17b17p34_inst (
	.clk	(clk		),
	.ce		(wb_mult_ce	),
	.a		(wb_mult_a	),
	.b		(wb_mult_b	),
	.p		(wb_mult_p	)
	);

	//  -------------------------------------------------------------------------------------
	//	乘法器两个输入端口
	//	1.输入端口都是17bit位宽，如果输入的数据位宽不足，需要用0补充高位
	//	2.乘法器a口是增益系数
	//	3.乘法器b口是像素数据
	//  -------------------------------------------------------------------------------------
	assign	wb_mult_a	= {{(17-WB_GAIN_WIDTH){1'b0}},gain_coe[WB_GAIN_WIDTH-1:0]};
	assign	wb_mult_b	= {{(17-SENSOR_DAT_WIDTH){1'b0}},pix_data_dly0[SENSOR_DAT_WIDTH-1:0]};

	//  -------------------------------------------------------------------------------------
	//	乘法器使能
	//	1.当行有效使能且增益使能打开的时候，乘法器才会使能
	//	2.否则，乘法器使能关闭
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		if(gain_enable&i_lval) begin
			wb_mult_ce	<= 1'b1;
		end
		else begin
			wb_mult_ce	<= 1'b0;
		end
	end

	//  -------------------------------------------------------------------------------------
	//	溢出位的解释
	//	乘法增益结果还需要右移 WB_RATIO 位，因为乘法增益系数与实际的系数有对应关系。比如 右移2位，相当于增益系数是实际系数的4倍。
	//  -------------------------------------------------------------------------------------
	//  -------------------------------------------------------------------------------------
	//	增益的溢出位
	//	1.wb_mult_p		- 乘法器总共位宽是34bit
	//	2.gain_all_data	- DSP输出结果的实际有效位宽是 WB_GAIN_WIDTH + SENSOR_DAT_WIDTH，即A口的宽度 + B口的宽度，高位是全0
	//	3.gain_reduce	- DSP输出结果中的有效数据位宽是 SENSOR_DAT_WIDTH + WB_RATIO，这其中包含了溢出位
	//	4.gain_overflow	- 溢出位宽是 WB_GAIN_WIDTH + SENSOR_DAT_WIDTH - (SENSOR_DAT_WIDTH + WB_RATIO) = SENSOR_DAT_WIDTH - WB_RATIO
	//  -------------------------------------------------------------------------------------
	//	assign	gain_all_data	= wb_mult_p[(WB_GAIN_WIDTH+SENSOR_DAT_WIDTH-1):0];
	assign	gain_reduce		= wb_mult_p[(WB_GAIN_WIDTH+SENSOR_DAT_WIDTH-1):WB_RATIO];
	assign	gain_overflow	= wb_mult_p[(WB_GAIN_WIDTH+SENSOR_DAT_WIDTH-1):SENSOR_DAT_WIDTH+WB_RATIO];

	//  ===============================================================================================
	//	ref ***数据输出***
	//  ===============================================================================================
	//  -------------------------------------------------------------------------------------
	//	输出的像素数据
	//	1.当行场都有效时
	//	--1.1当乘法增益不使能时，直接输出输入的数据。使用打两拍之后的数据。
	//	--1.2当乘法增益使能时，如果溢出位有1出现，说明已经溢出，则有效数据为全1
	//	--1.3当乘法增益使能时，如果高位是全0出现，说明没有溢出，输出乘法器输出结果
	//	2.当消隐时，数据屏蔽为0
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		if(fval_dly1==1'b1 && lval_dly1==1'b1) begin
			if(!gain_enable) begin
				pix_data_reg	<= pix_data_dly1;
			end
			else begin
				if(|gain_overflow) begin
					pix_data_reg	<= {SENSOR_DAT_WIDTH{1'b1}};
				end
				else begin
					pix_data_reg	<= gain_reduce[SENSOR_DAT_WIDTH-1:0];
				end
			end
		end
		else begin
			pix_data_reg	<= {SENSOR_DAT_WIDTH{1'b0}};
		end
	end
	assign	ov_pix_data	= pix_data_reg;

	//  -------------------------------------------------------------------------------------
	//	行场信号延迟 共延迟3拍
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		fval_dly0	<= i_fval;
		fval_dly1	<= fval_dly0;
		fval_dly2	<= fval_dly1;
	end
	assign	o_fval	= fval_dly2;

	//	-------------------------------------------------------------------------------------
	//	当输入场信号=0时，输出的行信号要屏蔽
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		lval_dly0	<= i_lval;
		lval_dly1	<= lval_dly0;
		if(fval_dly1) begin
			lval_dly2	<= lval_dly1;
		end
		else begin
			lval_dly2	<= 1'b0;
		end
	end
	assign	o_lval	= lval_dly2;


endmodule