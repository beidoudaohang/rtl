//-------------------------------------------------------------------------------------------------
//  -- 版权所有者   : 中国大恒（集团）有限公司北京图像视觉技术分公司, 2010 -2015.
//  -- 保密级别     ：绝密.
//  -- 部门         : 硬件部，FPGA工作组
//  -- 模块名       : bitslip
//  -- 设计者       : 周金剑
//-------------------------------------------------------------------------------------------------
//
//  -- 版本记录 :
//
//  -- 作者         :| 修改日期				:|  修改说明
//-------------------------------------------------------------------------------------------------
//  -- 周金剑       :| 2015/08/11 13:46:45	:|  初始版本
//-------------------------------------------------------------------------------------------------
//
//  -- 模块描述     : 根据HiSPi协议的同步字对齐word边界
//					 在进行对齐操作时，以lane1为参考，lane1数据对齐则其他lane也应该是对齐的。如果在
//					 实际中其他lane没有对齐，则说明其他lane与时钟的相位关系不对，需对数据进行相位调整。
//             		 因为检测的依据是同步字，所以在没有检测到同步字时，每隔1个行周期进行一次检测。
//
//-------------------------------------------------------------------------------------------------
//仿真单位/精度
`timescale 1ns/1ns
//-------------------------------------------------------------------------------------------------
module bitslip # (
	parameter		SER_FIRST_BIT			= "LSB"				,	//"LSB" or "MSB" , first bit to the receiver
	parameter		END_STYLE				= "LITTLE"			,	//"LITTLE" or "BIG" , "LITTLE" - {CHANNEL3 CHANNE2 CHANNEL1 CHANNEL0}. "BIG" - {CHANNEL0 CHANNEL1 CHANNEL2 CHANNEL3}.
	parameter		SENSOR_DAT_WIDTH		= 12				,	//sensor像素数据位宽
	parameter		RATIO					= 6					,	//解串因子
	parameter		CHANNEL_NUM				= 4						//通道数
	)
	(
	input												clk						,	//输入并行时钟
	input												reset					,	//并行时钟域复位信号
	input	[RATIO*CHANNEL_NUM-1:0]						iv_data					,	//输入并行数据
	input	[15:0]										iv_line_length			,	//行周期
	input												i_bitslip_en			,	//bitslip使能，为高电平时进行对齐操作
	output												o_bitslip				,	//输出bitslip使能，连接selectIO
	output												o_data_valid			,	//通道数据有效信号
	output												o_clk_en				,	//时钟使能信号
	output	[SENSOR_DAT_WIDTH*CHANNEL_NUM-1:0]			ov_data						//已经对齐后的数据
	);

	//ref signals

	//	-------------------------------------------------------------------------------------
	//	hispi 的同步字
	//	--当是LSB时，先接收到低半字节，因此移位寄存器是右移。这样最先出来的word就在最右面。同步字是36'h000_000_fff。
	//	--当是MSB时，先接收到低半字节，因此移位寄存器是左移。这样最先出来的word就在最左面。同步字是36'hfff_000_000。
	//	-------------------------------------------------------------------------------------
	localparam	SYNC_WORD	= (END_STYLE=="LITTLE") ? {{4*RATIO{1'b0}},{2*RATIO{1'b1}}} : {{2*RATIO{1'b1}},{4*RATIO{1'b0}}};

	reg		[1:0]									bitslip_en_shift		;	//对位使能打两拍
	wire	[RATIO-1:0]								wv_data_lane[CHANNEL_NUM-1:0]	;	//重新组合的通道1的数据
	reg		[2*RATIO-1:0]							data_lane_align[CHANNEL_NUM-1:0]	;	//重新组合的通道1的数据
	reg												div_cnt					= 1'b0	;	//分频计数器
	reg		[RATIO*6-1:0]							data_lane0_shift		= 'b0	;	//lan0通道移位寄存器

	reg												data_lock				= 'b0	;	//边界对齐标志位，1表示边界已经对齐
	reg		[15:0]									bitslip_cnt				= 'b0	;	//对齐计数器，每个行周期进行一次对齐操作
	reg												bitslip_reg				= 1'b0	;	//iserdes对位使能信号

	//ref ARCHITECTURE
	//	===============================================================================================
	//	ref ***异步时钟域处理***
	//	===============================================================================================
	//	-------------------------------------------------------------------------------------
	//	i_bitslip_en为clk_pix时钟域，转换到i_clk_parallel时钟域
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk)begin
		bitslip_en_shift	<=	{bitslip_en_shift[0],i_bitslip_en};
	end

	//	===============================================================================================
	//	ref ***检测同步字***
	//	===============================================================================================
	//	-------------------------------------------------------------------------------------
	//	划分通道
	//	--每个通道的位宽是 RATIO 个bit
	//	--大端，最高的通道在低byte。小端，最低的通道在低byte。
	//	-------------------------------------------------------------------------------------
	genvar	i;
	generate
		for(i=0;i<CHANNEL_NUM;i=i+1) begin
			if(END_STYLE=="LITTLE") begin
				assign	wv_data_lane[i]	= iv_data[RATIO*(i+1)-1:RATIO*i];
			end
			else if(END_STYLE=="BIG") begin
				assign	wv_data_lane[i]	= iv_data[RATIO*(CHANNEL_NUM-i)-1:RATIO*(CHANNEL_NUM-i-1)];
			end
		end
	endgenerate

	//	-------------------------------------------------------------------------------------
	//	对lan0移位，每次移动 RATIO 个bit
	//	--目前的检测方法是只对lane0检测同步字。其他通道不检测
	//	--lan0的 RATIO bit数据每次移位。注意，此处无论是LSB MSB ，都是将数据从最低端移到最高端
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		if(SER_FIRST_BIT=="LSB") begin
			data_lane0_shift	<= {wv_data_lane[0],data_lane0_shift[RATIO*6-1:RATIO]};
		end
		else if(SER_FIRST_BIT=="MSB") begin
			data_lane0_shift	<= {data_lane0_shift[RATIO*5-1:0],wv_data_lane[0]};
		end
	end

	//	-------------------------------------------------------------------------------------
	//	检测同步字
	//	--检测到{{L{1'b1}},{L{1'b0}},{L{1'b0}}}则表示检测到同步字，同时边界也是对齐的
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk)begin
		if(reset==1'b1 || bitslip_en_shift[1]==1'b0)begin
			data_lock	<=	0;
		end
		else begin
			if(data_lane0_shift[RATIO*6-1:0]==SYNC_WORD)begin
				data_lock	<=	1;
			end
		end
	end

	//	-------------------------------------------------------------------------------------
	//	以LSB为例，说明data lock与拼接逻辑
	//	-------------------------------------------------------------------------------------
	//	-------------------------------------------------------------------------------------
	//			  	  ____   ____   ____   ____   ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
	//	clk_2x		__|  |___|  |___|  |___|  |___|  |___|  |___|  |___|  |___|  |___|  |___|  |___|  |___|  |___|  |___
	//
	//	byte in		--<L0    ><H0   ><L1   ><H1   ><L2   ><H2   ><L3   ><H3   ><L4   ><H4   ><L5   ><H5   ><L6   ><H6   >
	//
	//									                 ______________________________________________________________________
	//	data lock	_____________________________________|
	//
	//	byte shift	------------------------------<L0H0L1H1>
	//
	//	data align	-------------------------------------<L2H1  ><H2L2 ><L3H2 ><H3L3 ><L4H3 ><H4L4 ><L5H4 ><H5L5 ><L6H5 >
	//						    								________      ________      ________      ________
	//	clk en		____________________________________________|      |______|      |______|      |______|      |______
	//
	//
	//	-------------------------------------------------------------------------------------

	//	===============================================================================================
	//	ref ***拼接数据***
	//	===============================================================================================
	//	-------------------------------------------------------------------------------------
	//	每个通道各延时1拍
	//	--2个 RATIO bit，拼成一个word
	//	--LSB模式，先接收到的 RATIO bit是低位。MSB模式，先接收到的 RATIO bit是高位
	//	-------------------------------------------------------------------------------------
	genvar	j;
	generate
		for(j=0;j<CHANNEL_NUM;j=j+1) begin
			if(SER_FIRST_BIT=="LSB") begin
				always @ (posedge clk) begin
					data_lane_align[j]	= {wv_data_lane[j],data_lane_align[j][2*RATIO-1:RATIO]};
				end
			end
			else if(SER_FIRST_BIT=="MSB") begin
				always @ (posedge clk) begin
					data_lane_align[j]	= {data_lane_align[j][RATIO-1:0],wv_data_lane[j]};
				end
			end
		end
	endgenerate

	//	-------------------------------------------------------------------------------------
	//	div_cnt 分频计数器
	//	--只在 data_lock == 1的时候才开始计数
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		if(!data_lock) begin
			div_cnt	<= 'b0;
		end
		else begin
			div_cnt	<= !div_cnt;
		end
	end
	assign	o_clk_en	= div_cnt;

	//	===============================================================================================
	//	ref ***bitslip 输出逻辑***
	//	===============================================================================================
	//	-------------------------------------------------------------------------------------
	//	行周期计数器
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk)begin
		if(reset==1'b1 || bitslip_en_shift[1]==1'b0)begin
			bitslip_cnt	<=	'd0;
		end
		else begin
			if(bitslip_cnt==iv_line_length) begin
				bitslip_cnt	<= 'b0;
			end
			else begin
				bitslip_cnt	<= bitslip_cnt + 1'b1;
			end
		end
	end

	//	-------------------------------------------------------------------------------------
	//	在一行之中没有检测到同步字，则移位
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		if(reset==1'b1 || bitslip_en_shift[1]==1'b0)begin
			bitslip_reg	<= 1'b0;
		end
		else begin
			if(bitslip_cnt==iv_line_length) begin	//每个行周期检测一次同步字
				bitslip_reg	<= !data_lock;
			end
			else begin
				bitslip_reg	<= 1'b0;
			end
		end
	end
	assign	o_bitslip	= bitslip_reg	;

	//	===============================================================================================
	//	ref ***输出***
	//	===============================================================================================
	//	-------------------------------------------------------------------------------------
	//	输出对齐信号
	//	-------------------------------------------------------------------------------------
	assign	o_data_valid	= data_lock;

	//	-------------------------------------------------------------------------------------
	//	输出对齐后的数据，区分大小端
	//	-------------------------------------------------------------------------------------
	genvar	l;
	generate
		for(l=0;l<CHANNEL_NUM;l=l+1) begin
			if(END_STYLE=="LITTLE") begin
				assign	ov_data[(l+1)*SENSOR_DAT_WIDTH-1:l*SENSOR_DAT_WIDTH]	= data_lane_align[l];
			end
			else if(END_STYLE=="BIG") begin
				assign	ov_data[(l+1)*SENSOR_DAT_WIDTH-1:l*SENSOR_DAT_WIDTH]	= data_lane_align[CHANNEL_NUM-l-1];
			end
		end
	endgenerate




endmodule